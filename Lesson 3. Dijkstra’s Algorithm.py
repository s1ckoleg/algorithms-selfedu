"""
Алгоритм необходим для определения минимальных весов для каждого узла графа.
https://www.youtube.com/watch?v=MCfjc_UIP1M&list=PLA0M1Bcd0w8yF0PO0eJ9v8VlsYEowmsnJ&index=3
"""

import math


def get_links(v, D):  # находит все вершины связанные с вершиной v
    for i, weight in enumerate(D[v]):
        if weight > 0:
            yield i


def find_min(T, S):  # находит узел с минимальным значением веса
    arg_min = -1
    m = math.inf

    for i, t in enumerate(T):
        if t < m and i not in S:
            m = t
            arg_min = i

    return arg_min


D = ((0, 3, 1, 3, 0, 0, 0),  # матрица смежности графа
     (3, 0, 4, 0, 0, 0, 0),
     (1, 4, 0, 0, 7, 5, 0),
     (3, 0, 0, 0, 0, 2, 0),
     (0, 0, 7, 0, 0, 4, 0),
     (0, 0, 5, 2, 4, 0, 1),
     (0, 0, 0, 0, 0, 1, 0))

N = len(D)  # число вершин в графе
T = [math.inf]*N  # заполнили таблицу результатов бесконечностями

v = 0  # стартовая вершина
S = {v}  # просмотренные вершины
T[v] = 0  # задаём нулевой вес для стартовой вершины
M = [0]*N  # оптимальные свзяи между вершинами

while v != -1:  # цикл по всем вершинам

    for j in get_links(v, D):
        if j not in S:
            w = T[v] + D[v][j]  # находим текущий вес связи, складываем начальный вес с весом дуги
            if w < T[j]:  # если текущий вес связи меньше чем старый, то добавляем его в таблицу
                T[j] = w
                M[j] = v  # связываем вершину j с вершиной v

    v = find_min(T, S)  # выбираем следующий узел с минимальным весом
    if v >= 0:
        S.add(v)  # добавляем новую вершину в рассмотрение

print(T)
print(M)

# формирование оптимального маршрута:
start = 0
end = 6
P = [end]
while end != start:
    end = M[P[-1]]
    P.append(end)

print(P[::-1])

"""
Алгоритм необходим для определения максимальной пропускной способности потока в направленном графе, то есть решает
задачу нахождения максимального потока в транспортной сети.
https://www.youtube.com/watch?v=I0bBIHCaSDo&list=PLA0M1Bcd0w8yF0PO0eJ9v8VlsYEowmsnJ&index=5
"""
import math


def get_max_vertex(k, V, S):
    m = 0  # наибольшая пропускная способность
    v = -1  # номер вершины

    for i, w in enumerate(V[k]):

        if i in S:  # если вершина уже рассмотрена, то пропускаем её
            continue

        if w[2] == 1:  # по направлению стрелки
            if m < w[0]:
                m = w[0]
                v = i
        else:          # против движения стрелки
            if m < w[1]:
                m = w[1]
                v = i

    return v


def get_max_flow(T):
    w = [x[0] for x in T]
    return min(w)


def update_v(V, T, f):
    for t in T:
        if t[1] == -1:
            continue

        sgn = V[t[2]][t[1]][2]  # направление движения

        # меняем веса в таблице для (i,j) и (j,i)
        V[t[1]][t[2]][0] -= f * sgn
        V[t[1]][t[2]][1] += f * sgn

        V[t[2]][t[1]][0] -= f * sgn
        V[t[2]][t[1]][1] += f * sgn


V = [[[0, 0, 1], [20, 0, 1], [30, 0, 1], [10, 0, 1], [0, 0, 1]],  # матрица, характеризующая направленный граф
     [[20, 0, -1], [0, 0, 1], [40, 0, 1], [0, 0, 1], [30, 0, 1]],
     [[30, 0, -1], [40, 0, -1], [0, 0, 1], [10, 0, 1], [20, 0, 1]],
     [[10, 0, -1], [0, 0, 1], [10, 0, -1], [0, 0, 1], [20, 0, 1]],
     [[0, 0, 1], [30, 0, -1], [20, 0, -1], [20, 0, -1], [0, 0, 1]]]

N = len(V)  # число вершин в графе
init = 0  # вершина истока
end = 4  # вершина стока
Tinit = [math.inf, -1, init]  # метка стока
f = []  # максимальные потоки каждого маршрута

j = init  # следующая вершина
while j != -1:
    k = init  # текущая рассматриваемая вершина
    T = [Tinit]  # метки вершин маршрута
    S = {init}  # множество рассмотренных вершин

    while k != end:  # пока не дошли до стока
        j = get_max_vertex(k, V, S)  # выбираем следующую вершину с наибольшей пропускной способностью
        if j == -1:        # если следующих вершин нет
            if k == init:  # и мы на истоке
                break      # завершаем работу алгоритма
            else:          # иначе переходим к предыдущей вершине графа
                k = T[-1][2]
                continue

        c = V[k][j][2] if V[k][j][2] == 1 else V[k][j][1]  # определяем текущий поток
        T.append((c, j, k))  # добавляем метку
        S.add(j)  # запоминаем вершину, как просмотренную

        if j == end:  # если дошли до стока
            f.append(get_max_flow(T))  # определяем максимальную пропускную способность маршрута
            update_v(V, T, f[-1])  # обновляем веса дуг
            break

        k = j

print("Максимальный поток графа равен: " + str(sum(f)))
